// CLI output.
pub(crate) mod output;

use crate::artifact::{JsonTrace, TlaConfigFile, TlaFile, TlaTrace};
use crate::Error;
use clap::{AppSettings, Clap, Subcommand};
use serde_json::{json, Value as JsonValue};
use std::collections::HashSet;
use std::path::Path;

/// A struct that generates a CLI for `modelator` using [`clap`].
#[derive(Clap, Debug)]
#[clap(name = "modelator")]
#[clap(setting = AppSettings::DisableHelpSubcommand)]
pub struct CliOptions {
    #[clap(subcommand)]
    subcommand: Modules,
}

#[derive(Debug, Subcommand)]
enum Modules {
    /// Generate TLA+ test cases and parse TLA+ traces.
    Tla(TlaMethods),
    /// Generate TLA+ traces using Apalache.
    Apalache(ApalacheMethods),
    /// Generate TLA+ traces using TLC.
    Tlc(TlcMethods),
}

#[derive(Debug, Clap)]
#[clap(setting = AppSettings::DisableHelpSubcommand)]
enum TlaMethods {
    /// Generate TLA+ tests.
    GenerateTests {
        /// TLA+ file with test cases.
        tla_file: String,
        /// TLA+ config file with CONSTANTS, INIT and NEXT.
        tla_config_file: String,
    },
    /// Convert a TLA+ trace to a JSON trace.
    TlaTraceToJsonTrace {
        /// File with a TLA+ trace produced by the Apalache or TLC modules.
        tla_trace_file: String,
    },
}

#[derive(Debug, Clap)]
#[clap(setting = AppSettings::DisableHelpSubcommand)]
enum ApalacheMethods {
    /// Generate TLA+ trace from a TLA+ test.
    Test {
        /// TLA+ file generated by the generate-test method in the TLA module.
        tla_file: String,
        /// TLA+ config file generated by the generate-test method in the TLA module.
        tla_config_file: String,
    },
    /// Parse a TLA+ file.
    Parse {
        /// TLA+ file to be parsed.
        tla_file: String,
    },
    /// Extract the TLA+ variables from a TLA+ file.
    TlaVariables {
        /// TLA+ file from where to extract TLA+ variables.
        tla_file: String,
    },
}

const NEXT_STATES_COUNT: &str = "10";
const NEXT_STATES_SKIP: &str = "0";

#[derive(Debug, Clap)]
#[clap(setting = AppSettings::DisableHelpSubcommand)]
enum TlcMethods {
    /// Generate TLA+ trace from a TLA+ test.
    Test {
        /// TLA+ file generated by the generate-test method in the TLA module.
        tla_file: String,
        /// TLA+ config file generated by the generate-test method in the TLA module.
        tla_config_file: String,
    },
    /// Explore a TLA+ model.
    NextStates {
        /// TLA+ file.
        tla_file: String,
        /// TLA+ config file.
        tla_config_file: String,
        /// TLA+ state from where to start. If not set, then initial TLA+ state
        /// will be used. TLA+ states returned by previous invokations of this
        /// command can be used as argument here.
        #[clap(short, long)]
        start_state: Option<String>,
        /// Maximum number of next states to return.
        #[clap(long, default_value = NEXT_STATES_COUNT)]
        count: usize,
        /// Number of next states to be skipped (for pagination).
        #[clap(long, default_value = NEXT_STATES_SKIP)]
        skip: usize,
    },
}

impl CliOptions {
    /// Function that runs `modelator` given the parameters in the [CliOptions].
    pub fn run(self) -> output::CliOutput {
        let result = self.subcommand.run();
        output::CliOutput::with_result(result)
    }
}

impl Modules {
    fn run(self) -> Result<JsonValue, Error> {
        // setup modelator
        let options = crate::Options::default();
        crate::setup(&options)?;

        // run the subcommand
        match self {
            Self::Tla(options) => options.run(),
            Self::Apalache(options) => options.run(),
            Self::Tlc(options) => options.run(),
        }
    }
}

impl TlaMethods {
    fn run(self) -> Result<JsonValue, Error> {
        match self {
            Self::GenerateTests {
                tla_file,
                tla_config_file,
            } => Self::generate_tests(tla_file, tla_config_file),
            Self::TlaTraceToJsonTrace { tla_trace_file } => {
                Self::tla_trace_to_json_trace(tla_trace_file)
            }
        }
    }

    fn generate_tests(tla_file: String, tla_config_file: String) -> Result<JsonValue, Error> {
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_config_file = TlaConfigFile::try_from(tla_config_file)?;
        let tests = crate::module::Tla::generate_tests(tla_file, tla_config_file)?;
        tracing::debug!("Tla::generate_tests output {:#?}", tests);

        generated_tests(tests)
    }

    fn tla_trace_to_json_trace(tla_trace_file: String) -> Result<JsonValue, Error> {
        let tla_trace_file = Path::new(&tla_trace_file);
        if !tla_trace_file.is_file() {
            return Err(Error::FileNotFound(tla_trace_file.to_path_buf()));
        }
        let tla_trace = std::fs::read_to_string(&tla_trace_file)
            .map_err(Error::io)?
            .parse()?;

        // convert tla trace to json trace
        let json_trace = crate::module::Tla::tla_trace_to_json_trace(tla_trace)?;
        tracing::debug!("Tla::tla_trace_to_json_trace output {}", json_trace);

        save_json_trace(json_trace)
    }
}

impl ApalacheMethods {
    fn run(self) -> Result<JsonValue, Error> {
        match self {
            Self::Test {
                tla_file,
                tla_config_file,
            } => Self::test(tla_file, tla_config_file),
            Self::Parse { tla_file } => Self::parse(tla_file),
            Self::TlaVariables { tla_file } => Self::tla_variables(tla_file),
        }
    }

    fn test(tla_file: String, tla_config_file: String) -> Result<JsonValue, Error> {
        let options = crate::Options::default();
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_config_file = TlaConfigFile::try_from(tla_config_file)?;
        let tla_trace = crate::module::Apalache::test(tla_file, tla_config_file, &options)?;
        tracing::debug!("Apalache::test output {}", tla_trace);

        save_tla_trace(tla_trace)
    }

    fn parse(tla_file: String) -> Result<JsonValue, Error> {
        let options = crate::Options::default();
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_file_parsed = crate::module::Apalache::parse(tla_file, &options)?;
        tracing::debug!("Apalache::parse output {}", tla_file_parsed);

        parsed_tla_file(tla_file_parsed)
    }

    fn tla_variables(tla_file: String) -> Result<JsonValue, Error> {
        let options = crate::Options::default();
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_variables = crate::module::Apalache::tla_variables(tla_file, &options)?;
        tracing::debug!("Apalache::tla_variables output {:?}", tla_variables);

        extracted_tla_variables(tla_variables)
    }
}

impl TlcMethods {
    fn run(self) -> Result<JsonValue, Error> {
        match self {
            Self::Test {
                tla_file,
                tla_config_file,
            } => Self::test(tla_file, tla_config_file),
            Self::NextStates {
                tla_file,
                tla_config_file,
                start_state,
                count,
                skip,
            } => Self::next_states(tla_file, tla_config_file, start_state, count, skip),
        }
    }

    fn test(tla_file: String, tla_config_file: String) -> Result<JsonValue, Error> {
        let options = crate::Options::default();
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_config_file = TlaConfigFile::try_from(tla_config_file)?;
        let tla_trace = crate::module::Tlc::test(tla_file, tla_config_file, &options)?;
        tracing::debug!("Tlc::test output {}", tla_trace);

        save_tla_trace(tla_trace)
    }

    fn next_states(
        tla_file: String,
        tla_config_file: String,
        start_state: Option<String>,
        count: usize,
        skip: usize,
    ) -> Result<JsonValue, Error> {
        let options = crate::Options::default();
        use std::convert::TryFrom;
        let tla_file = TlaFile::try_from(tla_file)?;
        let tla_config_file = TlaConfigFile::try_from(tla_config_file)?;
        crate::module::Tlc::next_states(
            tla_file,
            tla_config_file,
            start_state,
            skip,
            count,
            options,
        )?;
        Ok(JsonValue::Null)
    }
}

#[allow(clippy::unnecessary_wraps)]
fn generated_tests(tests: Vec<(TlaFile, TlaConfigFile)>) -> Result<JsonValue, Error> {
    let json_array_entry = |tla_file: TlaFile, tla_config_file: TlaConfigFile| {
        json!({
            "tla_file": format!("{}", tla_file),
            "tla_config_file": format!("{}", tla_config_file),
        })
    };
    let json_array = tests
        .into_iter()
        .map(|(tla_file, tla_config_file)| json_array_entry(tla_file, tla_config_file))
        .collect();
    Ok(JsonValue::Array(json_array))
}

fn save_tla_trace(tla_trace: TlaTrace) -> Result<JsonValue, Error> {
    let path = Path::new("trace.tla").to_path_buf();
    std::fs::write(&path, format!("{}", tla_trace)).map_err(Error::io)?;
    Ok(json!({
        "tla_trace_file": crate::util::absolute_path(&path),
    }))
}

fn save_json_trace(json_trace: JsonTrace) -> Result<JsonValue, Error> {
    let path = Path::new("trace.json").to_path_buf();
    std::fs::write(&path, format!("{}", json_trace)).map_err(Error::io)?;
    Ok(json!({
        "json_trace_file": crate::util::absolute_path(&path),
    }))
}

#[allow(clippy::unnecessary_wraps)]
fn parsed_tla_file(tla_file_parsed: TlaFile) -> Result<JsonValue, Error> {
    Ok(json!({
        "tla_file": format!("{}", tla_file_parsed),
    }))
}

#[allow(clippy::unnecessary_wraps)]
fn extracted_tla_variables(tla_variables: HashSet<String>) -> Result<JsonValue, Error> {
    Ok(json!({
        "tla_variables": tla_variables,
    }))
}
